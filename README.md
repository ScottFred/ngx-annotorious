# NgxAnnotorious

This project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 19.0.5.

- [NgxAnnotorious](#ngxannotorious)
  - [Setup](#setup)
  - [Demo App](#demo-app)
  - [ImgAnnotatorDirective](#imgannotatordirective)
  - [ImgAnnotationList](#imgannotationlist)
  - [Issues](#issues)

This library is a minimalist set of components wrapping [Annotorious V3](https://annotorious.dev/) functionalities and used to easily integrate in an application a gallery of images from some online source and an image annotator with a user-defined model, not necessarily limited to the W3C annotation. In the bigger application where this is going to be used, Annotorious is used to select a portion of an image, while the model to be attached to it is user-defined.

## Setup

1. install Annotorious in your Angular app:
   - `npm i @annotorious/annotorious @myrmidon/ngx-annotorious`.
   - in angular.json, add to `styles` the value `"node_modules/@annotorious/annotorious/dist/annotorious.css"`.
2. for this library, in your `app.config`, configure the default **options for Material dialogs**, as annotations metadata are edited inside a popup, e.g.:

```ts
// in appConfig providers array:
{
  provide: MAT_DIALOG_DEFAULT_OPTIONS,
  useValue: {
    hasBackdrop: true,
    maxHeight: '800px',
  },
},
```

## Demo App

In this demo, the app component uses an image annotator component wrapping the core components from this workspace.

The app component contains:

- a toolbar component for tool selection ([ImgAnnotationToolbar](./projects/myrmidon/ngx-annotorious/src/lib/components/img-annotator-toolbar/img-annotator-toolbar.component.ts));
- an `img` with a simple image loaded from the application assets for demo purposes. This element is decorated with a directive wrapping the Annotorious functionality ([ImgAnnotatorDirective](./projects/myrmidon/ngx-annotorious/src/lib/directives/img-annotator.directive.ts));
- a list of annotations.

## ImgAnnotatorDirective

The core of the library is the lightweight directive [ImgAnnotatorDirective](./projects/myrmidon/ngx-annotorious/src/lib/directives/img-annotator.directive.ts) used to wrap an Annotorious annotator. This takes care of initializing an `ImageAnnotator` instance at the right time in the Angular component lifecycle, configure it as required, wrap its main functions, and and attach listeners to its events to forward them to its Angular consumer.

## ImgAnnotationList

Other components are then provided to ease the usage of this directive in the context of an images gallery. Currently, only a subset of these components are present in this repository because this is mainly provided as a repro for issues in dealing with Annotorious in Angular, and every non-relevant piece of code would just add rumor.

The core logic for orchestrating events and actions for the wrapped annotator is implemented in a generic `ImgAnnotationList` class. This keeps its own storage of annotations, so that it includes any third-party model, whatever its complexity, attached to the selected portion of an image; and provides a simple API surface to be consumed by other Angular components.

The extended annotation model for this list, `ListAnnotation<T>`, is a wrapper for the Annotorious annotation including an additional payload of type `T`.

This custom model is stored in a parallel storage mantained by the image annotator component. This storage is kept in synch with the `ImageAnnotator` storage by listening to its deletion and selection change events. In the end, on the Angular side only this synched storage is important, because it will hold all the annotations generated by the `ImageAnnotator` wrapped in a larger structure including a payload implementing a specific third-party model.

The annotations list API is:

- properties:
  - `annotations$`: observable of `ListAnnotation<T>[]`.
  - `selectedAnnotation$`: observable of `ListAnnotation<T>` or undefined, representing the currently selected annotation if any.
  - `annotationToString`: a function used to build a string representing a `ListAnnotation<T>`.
  - `image`: the reference `GalleryImage`.
- methods:
  - `getAnnotations()`
  - `clearAnnotations()`
  - `setAnnotations(annotations: ListAnnotation<T>[])`
  - `removeAnnotation(id: string)`
  - `editAnnotation(annotation: ImageAnnotation, isNew?: boolean)`
  - `selectAnnotation(annotation?: ListAnnotation<T>)`
  - `editAnnotationAt(index: number)`
  - `selectAnnotationAt(index: number)`
  - `removeAnnotationAt(index: number)`
- event handlers:
  - `onCreateAnnotation(annotation: ImageAnnotation)`
  - `onSelectionChange(annotation?: ImageAnnotation)`
  - `onDeleteAnnotation(annotation: ImageAnnotation)`

In this list, I apply the following logic:

- **creating** annotation:
  1. the annotation component takes care of wiring the `createAnnotation` event received from the wrapper directive to the `onCreateAnnotation` of the list. So, whenever this event is fired, `onCreateAnnotation` gets called.
  2. the received annotation is edited in a custom popup.
  3. if the editor is dismissed, just delete the created annotation from Annotorious.
  4. otherwise, and add the edited annotation to Annotorious ( optionally enriched with items in its `bodies` array by the editor), and its extended version (with the custom payload) in the list storage.

- **updating** annotation:
  1. `editAnnotation` is invoked with the `ImageAnnotation` to edit. The list finds the corresponding extended annotation in list storage, and extends the model with payload before editing it.
  2. the annotation is edited in a custom popup.
  3. if the editor is dismissed, do nothing.
  4. otherwise, update the annotation both in Annotator and in its list storage.

- **deleting** annotation: if this starts from an Annotorious event, delete the corresponding annotation in the list storage. Else, delete the annotation both from Annotorious and from list storage.

- **selecting** annotation: if this starts from an Annotorious event, select the corresponding annotation in the list storage. Else, remove selection from Annotorious, and if a selected annotation is requested select it both in Annotorious and in list storage; else, cancel selection in list storage.

## Issues

üêõ The main issue is that the wrapped `ImageAnnotator` does not seem to correctly respond when its API is invoked.

For instance:

1. create an annotation. This works and the popup editor appears. Type something in it (the demo extended model just corresponds to a string) and click OK.
2. the annotation is added both in Annotorious and in list store.
3. delete the annotation, or just delete all the annotations via the bottom clear button. The annotation visuals persist on the image.

This implies that if I click Cancel in (1), the created annotation is not removed, even if I invoke deleteAnnotation with its ID.

So, this makes the whole logic in the list break, as I can't properly integrate with the wrapped Annotorious instance.
